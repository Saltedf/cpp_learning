/*
对象模型：
类是图纸。对象是产品。
没有对象则无法调用方法
对数据结构能执行的操作全都在public区中列出了


调用某对象X的某方法Y可视为向对象X发送消息Y
方法的实际执行可视为对象X相应了消息Y


 对象是类的实例。
 每个对象中的非静态成员变量都是一个独立的副本，而成员函数则是共享的，在内存中只有一份。

“一个对象就是一个有限状态机”
 对象中的所有私有成员变量的值的组合可以视为“状态”，调用对象X的方法Y可视为向对象X发送消息Y，
 函数的实际执行可视为对消息的响应，在响应过程中的行为可大致分为两类：
    1、向其他对象发送消息
    2、修改自身状态（在cpp中不修改自身状态的成员方法被const标记）
对象对消息的响应方式依赖于自身当前的状态，因此正确的状态维护是重要的，状态只能被成员函数修改


建立对象模型的关键三要素：
    数据抽象：重点在对象的行为的设计 ，即要确定有哪些接口
    封装：抽象先于封装，为了隐藏实现细节
    层次：继承（一般-特殊、代码复用）+聚集（包含、共享）

哪些内容需要进行封装：
对调用者没用的
以后很有可能会变化的
敏感数据、复杂操作等

抽象的可靠性保障： 在C++中可以用assert实现
类不变式：该类的对象在整个生命周期中需要满足的条件
前置条件：成员函数在开始时需要检查的条件
后置条件：成员函数在结束时需要检查的条件

assert( ( message , (condition) ) )

*/